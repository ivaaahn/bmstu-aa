\chapter{Исследовательская часть}

В данном разделе представлен пользовательский интерфейс, а
также проведена оценка эффективности алгоритмов.


\section{Постановка эксперимента}

Технические характеристики устройства, на котором выполнялся эксперимент:
\begin{itemize}
	\item операционная система: Ubuntu\cite{ubuntu} Linux x86\_64;
	\item память: 16 GiB;
	\item процессор: AMD Ryzen™ 7 4700U\cite{amd}.
\end{itemize}

Проводятся эксперименты следующего типа:
\begin{enumerate}
	\item Сравнение времени обработки заявок на конвейере с разным 
	кол-вом сопрограмм и использование однопоточной последовательной обработки.
	\item Подсчет максимального, минимального и среднего времени:
	\begin{enumerate}
		\item проведенного задачей в системе;
		\item проведенного задачей в очередях.
	\end{enumerate}
	\item Анализ трассировки программы.
\end{enumerate}


Так как в реализуемом конвейере реализуются fan-out и fan-in подходы, особый интерес представляет 
зависимость временных характеристик системы от количества параллельных сопрограмм. А также 
сравнение непосредственно однопоточной последовательной реализации и конвеера.

Для сравнения возьмем конвейеры с соответствующим числом сопрограмм из набора [1, 2, 4, …, 64].

На момент тестирования в файловой системе машины, на которой проводились тесты,
насчитывалось 69257 файлов различного типа и размера. В ходе проведения эксперимента 
данная величина оставалась неизменной.

Так как в общем случае вычисление хеш-суммы файла является достаточно короткой задачей, 
воспользуемся усреднением массового эксперимента. Для этого вычислим среднее
арифметическое значение временных ресурсов, затраченных на выполнение алгоритма, для
\code{n} запусков. Сравнение произведем при \code{n} = 100.


\section{Результат эксперимента}

В таблице \ref{tab:profiling-1} приведены результаты сравнения работы однопоточного последовательного алгоритма и конвейера с
различным числом сопрограмм.

Видно, что последовательная реализация алгоритма уступает конвейерной даже с 1 сопрограммой почти на 30\%,
 а при конвейере в 16 сопрограммами - уже почти в 4 раза.

\begin{table}[!htb]
	\begin{center}
		\captionof{table}{Сравнение последовательного алгоритма и конвейера}
		\begin{tabular}{|c|c|} 
			\hline
			Реализация & Время выполнения (c)  \\  
			\hline
			Последовательная, 1 поток & 8.94  \\
			\hline
			Конвейер (1 сопрограмма) & 7.02  \\
			\hline
			Конвейер (2 сопрограммы) & 4.17  \\
			\hline
			Конвейер (4 сопрограмма) & 2.93   \\
			\hline
			Конвейер (8 сопрограмм) & 2.31 \\
			\hline
			Конвейер (16 сопрограмм) & 2.28 \\
			\hline
			Конвейер (32 сопрограммы) & 2.28  \\
			\hline
			Конвейер (64 сопрограмма) & 2.32 \\
			\hline
		\end{tabular}
		\label{tab:profiling-1}
	\end{center}
\end{table}

В таблицах \ref{tab:profiling-queue} -- \ref{tab:profiling-all} отображены результаты анализа среднего, минимального 
и максимального времени нахождения задачи в системе и в очереди.



\begin{table}[!ht]
	\begin{center}
		\captionof{table}{Время выполнения алгоритмов (в мс) для отсортированного массива}
		\begin{tabular}{|c|c|c|c|} 
			\hline
			Кол-во сопрограмм & Мин. (c.) & Макс. (c.) & Среднее (c.)  \\  
			\hline
			1 & $\expnumber{0.8}{-3}$ & 2.72 & 1.38 \\
			\hline
			2 & $\expnumber{1.1}{-4}$ & 1.18 & 0.69 \\
			\hline
			4 & $\expnumber{1.5}{-5}$ & 0.54 & 0.36 \\
			\hline
			8 & $\expnumber{1.2}{-5}$ & 0.34 & 0.18 \\
			\hline
			16 & $\expnumber{0.9}{-5}$ & 0.16 & 0.06 \\
			\hline
		\end{tabular}
		\label{tab:profiling-queue}
	\end{center}
\end{table}


\begin{table}[!ht]
	\begin{center}
		\captionof{table}{Время выполнения алгоритмов (в мс) для отсортированного массива}
		\begin{tabular}{|c|c|c|c|} 
			\hline
			Кол-во сопрограмм & Мин. (c.) & Макс. (c.) & Среднее (c.)  \\  
			\hline
			1 & $\expnumber{2.5}{-3}$ & 6.77 & 3.45 \\
			\hline
			2 & $\expnumber{3.1}{-4}$ & 3.52 & 1.81 \\
			\hline
			4 & $\expnumber{4.4}{-5}$ & 1.91 & 0.94 \\
			\hline
			8 & $\expnumber{3.4}{-5}$ & 0.96 & 0.45 \\
			\hline
			16 & $\expnumber{2.5}{-5}$ & 0.34 & 0.12 \\
			\hline
		\end{tabular}
		\label{tab:profiling-all}
	\end{center}
\end{table}

Очевидным явялется тот факт, что при увеличении количества сопрограмм данное время уменьшается.

В зависимости от трудоемкости задач, выполняемых на том или ином этапе конвеера, время ожидания в очереди будет
увеличиваться или уменьшаться. На примере решаемой задачи, заметим, что время ожидания занимает примерно треть всей работы
системы.


Из данных, приведенных в Таблице \ref{tab:profiling-trace} следует, что обработка задач действительно происходит асинхронно -
 во время работы одной ленты, другие выполняют свои функции. Кроме того, видна работа принципа fan-in/fan-out - четвертая и 
 пятая задачи одновременно попали на две параллельные ленты номер 2.

\begin{table}[!ht]
	\begin{center}
		\captionof{table}{Трассировка конвейера}
		\begin{tabular}{|c|c|c|c|} 
			\hline
			Лента & Задача & Начало (µs) & Конец (µs) \\  
			\hline
			1 & 2 & 164.54 & 171.25 \\
			\hline
			2 & 2 & 193.18 & 233.20 \\
			\hline
			3 & 2 & 273.29 & 275.73 \\
			\hline
			1 & 3 & 174.50 & 183.26 \\
			\hline
			2 & 3 & 278.66 & 328.46 \\
			\hline
			3 & 3 & 358.56 & 361.35 \\
			\hline
			1 & 4 & 186.61 & 191.78 \\
			\hline
			2 & 4 & 238.44 & 264.625 \\
			\hline
			3 & 4 & 293.75 & 296.54 \\
			\hline
			1 & 5 & 194.09 & 221.88 \\
			\hline
			2 & 5 & 238.44 & 264.62 \\
			\hline
			3 & 5 & 282.92 & 285.79 \\
			\hline
		\end{tabular}
		\label{tab:profiling-trace}
	\end{center}
\end{table}


\section{Вывод}

Исходя из результатов проведенного эксперимента можно сделать следующие выводы.
Конвейерная обработка действительно может помочь снизить 
временные затраты на выполнение задачи, благодаря отстутствию ожидания
конца выполнения подзадачи, как в случае последовательного алгоритма. В
случае реализованного в рамках лабораторной работы алгоритма, как минимум на 30\%, что
не так уж много, поэтому прежде чем реализовывать конвейер, необходимо проанализировать
необходимость его использования, а также рассмотреть возможность распараллеливания отдельных
наиболее трудоемких этапов конвеера.

Использование подходов fan-in / fan-out, то есть использование разветвления --
нескольких потоков выполняющих параллельно один из этапов конвейера, существенно
снижает временные затраты, особенно в тех случаях, когда на данном этапе конвейера
выполняется более трудозатратная работа, чем на других. Данный подход позволил снизить временные
затраты алгоритма, рассматриваемого в рамках данной работы почти в 4 раза, по сравнению с последовательным
алгоритмом и в 3 раза в сравнении с конвейером без распараллеливания.
