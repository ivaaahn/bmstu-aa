\chapter{Аналитическая часть}

\section{Классический алгоритм перемножения матриц}

Пусть даны две прямоугольные матрицы, с размерностями $l$x$m$ и $m$x$n$ соответственно:

\begin{equation}
	A_{lm} = \begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1m}\\
		a_{21} & a_{22} & \ldots & a_{2m}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{l1} & a_{l2} & \ldots & a_{lm}
	\end{pmatrix},
	\quad
		B_{mn} = \begin{pmatrix}
		b_{11} & b_{12} & \ldots & b_{1n}\\
		b_{21} & b_{22} & \ldots & b_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		b_{m1} & b_{m2} & \ldots & b_{mn}
	\end{pmatrix},
\end{equation}

тогда матрица $C$
\begin{equation}
	C_{ln} = \begin{pmatrix}
		c_{11} & c_{12} & \ldots & c_{1n}\\
		c_{21} & c_{22} & \ldots & c_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		c_{l1} & c_{l2} & \ldots & c_{ln}
	\end{pmatrix},
\end{equation}

где
\begin{equation}
	\label{eq:M}
	c_{ij} =
		\sum_{r=1}^{m} a_{ir}b_{rj} \quad (i=\overline{1,l}; j=\overline{1,n})
\end{equation}

называется их произведением\cite{optimize}.

Для вычисления произведения двух матриц, каждая строка первой матрицы почленно умножается
на каждый столбец второй, затем подсчитывается сумма таких произведений и записывается в
соответствующую ячейку результирующей матрицы.

\section{Алгоритм Винограда для перемножения матриц}

Если рассмотреть результат умножения двух матриц, то видно, что каждый элемент в нем представляет собой скалярное произведение соответствующих строки и столбца исходных матриц.
Можно заметить также, что такое умножение допускает предварительную обработку, позволяющую часть работы выполнить заранее  \cite{win-book}. 

Рассмотрим два вектора $V = (v_1, v_2, v_3, v_4)$ и $W = (w_1, w_2, w_3, w_4)$. Их скалярное произведение равно:
\begin{equation}
	\label{eq:defmul}
	V \cdot W = v_1w_1 + v_2w_2 + v_3w_3 + v_4w_4
\end{equation}
что эквивалентно
\begin{equation}
	\label{eq:newmul}
		V \cdot W = (v_1 + w_2)(v_2 + w_1) + (v_3 + w_4)(v_4 + w_3) - v_1v_2 - v_3v_4 - w_1w_2 - w_3w_4.
\end{equation}

На первый взгляд неочевидно, в чем преимущество выражения \ref{eq:newmul}, поскольку оно требует вычисления большего 
количества операций, чем классическое \ref{eq:defmul}:
вместо четырёх умножений -- шесть, а вместо трёх сложений -- десять. Заметим, что выражение в правой части формулы \ref{eq:newmul}
допускает предварительную обработку: его части можно вычислить заранее и запомнить для каждой строки первой матрицы
и для каждого столбца второй, что позволит для каждого элемента выполнять лишь два умножения и пять сложений.
Из-за того, что операция сложения быстрее операции умножения в ЭВМ, на практике алгоритм должен работать быстрее стандартного.


\section{Вывод}

В данном разделе был рассмотрены классический алгоритм перемножения матриц и алгоритм Винограда, позволяющий сократить количество операций умножения, 
а также использовать предварительные рассчеты.